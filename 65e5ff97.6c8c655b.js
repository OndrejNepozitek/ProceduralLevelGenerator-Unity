(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{155:function(e,a,n){"use strict";n.r(a),n.d(a,"frontMatter",(function(){return o})),n.d(a,"metadata",(function(){return l})),n.d(a,"rightToc",(function(){return c})),n.d(a,"default",(function(){return p}));var t=n(2),i=n(6),r=(n(0),n(255)),o={title:"Pipeline tasks"},l={id:"version-1.0.3/generator-pipeline/pipeline-tasks",title:"Pipeline tasks",description:"Pipeline tasks contain all the logic of the procedural dungeon generator. They are reusable and configurable components which we compose together to make the whole generator work.",source:"@site/versioned_docs\\version-1.0.3\\generator-pipeline\\pipeline-tasks.md",permalink:"/Edgar-Unity/docs/1.0.3/generator-pipeline/pipeline-tasks",editUrl:"https://github.com/OndrejNepozitek/Edgar-Unity/tree/docusaurus/versioned_docs/version-1.0.3/generator-pipeline/pipeline-tasks.md",version:"1.0.3",sidebar:"version-1.0.3/docs",previous:{title:"Pipeline payload",permalink:"/Edgar-Unity/docs/1.0.3/generator-pipeline/pipeline-payload"},next:{title:"Run pipeline",permalink:"/Edgar-Unity/docs/1.0.3/generator-pipeline/run-pipeline"}},c=[{value:"Creating pipeline tasks",id:"creating-pipeline-tasks",children:[]},{value:"Inheriting from <code>PipelineTask</code>",id:"inheriting-from-pipelinetask",children:[{value:"Example",id:"example",children:[]},{value:"Pros and cons",id:"pros-and-cons",children:[]}]},{value:"Inheriting from <code>PipelineConfig</code>",id:"inheriting-from-pipelineconfig",children:[{value:"Example",id:"example-1",children:[]},{value:"Pros and cons",id:"pros-and-cons-1",children:[]}]}],s={rightToc:c};function p(e){var a=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(t.a)({},s,n,{components:a,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Pipeline tasks contain all the logic of the procedural dungeon generator. They are reusable and configurable components which we compose together to make the whole generator work."),Object(r.b)("h2",{id:"creating-pipeline-tasks"},"Creating pipeline tasks"),Object(r.b)("p",null,"There are currently 2 ways to create pipeline tasks - the first way is simpler but less flexible and the second way is the exact opposite - slightly more complex but also more flexible."),Object(r.b)("h2",{id:"inheriting-from-pipelinetask"},"Inheriting from ",Object(r.b)("inlineCode",{parentName:"h2"},"PipelineTask")),Object(r.b)("p",null,"The first way to create a pipeline task is to create a class that inherits from the ",Object(r.b)("inlineCode",{parentName:"p"},"PipelineTask")," class below. As you can see below, the ",Object(r.b)("inlineCode",{parentName:"p"},"PipelineTask")," class is abstract and you have to provide an implementation of the ",Object(r.b)("inlineCode",{parentName:"p"},"Process")," method."),Object(r.b)("pre",null,Object(r.b)("code",Object(t.a)({parentName:"pre"},{className:"language-csharp"}),'/// <summary>\n/// Base class for pipeline tasks. Used in simpler scenarios.\n/// </summary>\n/// <typeparam name="TPayload">Type of the payload</typeparam>\npublic abstract class PipelineTask<TPayload> : PipelineItem, IPipelineTask<TPayload> \n    where TPayload : class\n{\n    /// <summary>\n    /// Payload object.\n    /// </summary>\n    public TPayload Payload { get; set; }\n\n    /// <summary>\n    /// Method containing all the logic of the task.\n    /// </summary>\n    /// <remarks>\n    /// When this method is called, the Payload property is already set.\n    /// </remarks>\n    public abstract void Process();\n}\n')),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},Object(r.b)("strong",{parentName:"p"},"Note:")," ",Object(r.b)("inlineCode",{parentName:"p"},"PipelineTask<TPayload>")," inherits from ",Object(r.b)("inlineCode",{parentName:"p"},"PipelineItem")," and that class inherits from ",Object(r.b)("inlineCode",{parentName:"p"},"ScriptableObject"),". So every child of ",Object(r.b)("inlineCode",{parentName:"p"},"PipelineTask<TPayload>")," is a ",Object(r.b)("inlineCode",{parentName:"p"},"ScriptableObject"),".")),Object(r.b)("h3",{id:"example"},"Example"),Object(r.b)("p",null,"Imagine that we have payload defined as follows:"),Object(r.b)("pre",null,Object(r.b)("code",Object(t.a)({parentName:"pre"},{className:"language-csharp"}),"public class Payload {\n    public int Number { get; set; }\n}\n")),Object(r.b)("p",null,"Let's create a pipeline task that will subtract a number from the ",Object(r.b)("inlineCode",{parentName:"p"},"Payload.Number")," property and we want that number to be configurable in Editor:"),Object(r.b)("pre",null,Object(r.b)("code",Object(t.a)({parentName:"pre"},{className:"language-csharp"}),'[CreateAssetMenu(menuName = "Example tasks/Subtract task", fileName = "SubtractTask")]\npublic class SubtractTask : PipelineTask<Payload>\n{\n    public int ToSubtract;\n\n    public override void Process()\n    {\n        Payload.Number -= ToSubtract;\n    }\n}\n')),Object(r.b)("p",null,"You can see that I added the ",Object(r.b)("inlineCode",{parentName:"p"},"CreateAssetMenu")," attribute because we want to be able to create an instance of the task in the Editor. The rest of the code should be quite self-explanatory."),Object(r.b)("p",null,"To use this task, we first create an instance of the ",Object(r.b)("inlineCode",{parentName:"p"},"SubtractTask")," ScriptableObject and then drag that instance to the ",Object(r.b)("em",{parentName:"p"},"Generator pipeline script"),"."),Object(r.b)("h3",{id:"pros-and-cons"},"Pros and cons"),Object(r.b)("p",null,"The biggest ",Object(r.b)("em",{parentName:"p"},"disadvantage")," is that we have to specify exactly which payload class we want to use because Unity does not allow us to have generic ScriptableObjects. However, this may not be a problem if you do not plan to ever switch the implementation of the payload."),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},Object(r.b)("strong",{parentName:"p"},"Note:")," It is not exactly true that we have to specify which payload ",Object(r.b)("em",{parentName:"p"},"class")," we want to use. We can also use an ",Object(r.b)("em",{parentName:"p"},"interface"),". But what if we want to access properties from multiple interfaces? We can probably work around that but it is not very nice.")),Object(r.b)("h2",{id:"inheriting-from-pipelineconfig"},"Inheriting from ",Object(r.b)("inlineCode",{parentName:"h2"},"PipelineConfig")),Object(r.b)("p",null,"The second way to create a pipeline task is more flexible. Instead of creating a single class, we will need 2 classes - one will be a non-generic configuration class and the second one will be a generic task. We will inherit from the following two classes."),Object(r.b)("pre",null,Object(r.b)("code",Object(t.a)({parentName:"pre"},{className:"language-csharp"}),'/// <summary>\n/// Base class for configs of pipeline tasks.\n/// </summary>\n/// <remarks>\n/// Should be used together with <seealso cref="ConfigurablePipelineTask{TPayload,TConfig}"/>.\n/// </remarks>\npublic abstract class PipelineConfig : PipelineItem\n{\n\n}\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(t.a)({parentName:"pre"},{className:"language-csharp"}),'/// <summary>\n/// Base class for configurable pipeline tasks.\n/// </summary>\n/// <typeparam name="TPayload">Type of payload.</typeparam>\n/// <typeparam name="TConfig">Type of config.</typeparam>\npublic abstract class ConfigurablePipelineTask<TPayload, TConfig> : IConfigurablePipelineTask<TPayload, TConfig> \n    where TConfig : PipelineConfig \n    where TPayload : class\n{\n    /// <summary>\n    /// Payload object.\n    /// </summary>\n    public TPayload Payload { get; set; }\n\n    /// <summary>\n    /// Config object.\n    /// </summary>\n    public TConfig Config { get; set; }\n\n    /// <summary>\n    /// Method containing all the logic of the task.\n    /// </summary>\n    /// <remarks>\n    /// When this method is called, both Payload and Config properties are already set.\n    /// </remarks>\n    public abstract void Process();\n}\n')),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},Object(r.b)("strong",{parentName:"p"},"Note:")," ",Object(r.b)("inlineCode",{parentName:"p"},"PipelineConfig")," inherits from ",Object(r.b)("inlineCode",{parentName:"p"},"PipelineItem")," and that class inherits from ",Object(r.b)("inlineCode",{parentName:"p"},"ScriptableObject"),". So every child of ",Object(r.b)("inlineCode",{parentName:"p"},"PipelineConfig")," is a ",Object(r.b)("inlineCode",{parentName:"p"},"ScriptableObject"),".")),Object(r.b)("h3",{id:"example-1"},"Example"),Object(r.b)("p",null,"Imagine that we want to implement a task that chooses a random size for our dungeon and that we already have 2 payload interfaces - ",Object(r.b)("inlineCode",{parentName:"p"},"IDungeonPayload")," and ",Object(r.b)("inlineCode",{parentName:"p"},"IRandomGeneratorPayload"),". Payload implementation may look like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(t.a)({parentName:"pre"},{className:"language-csharp"}),"public interface IDungeonPayload\n{\n    int Size { get; set; }\n}\n\npublic interface IRandomGeneratorPayload\n{\n    Random Random { get; set; }\n}\n\npublic class Payload : IRandomGeneratorPayload, IDungeonPayload\n{\n    public Random Random { get; set; }\n\n    public int Size { get; set; }\n}\n")),Object(r.b)("p",null,"First we create a config for our task. We want to choose size from a predefined range."),Object(r.b)("pre",null,Object(r.b)("code",Object(t.a)({parentName:"pre"},{className:"language-csharp"}),'[CreateAssetMenu(menuName = "Example tasks/Random size task", fileName = "RandomSizeTask")]\npublic class RandomSizeConfig : PipelineConfig\n{\n    public int MinSize;\n\n    public int MaxSize;\n}\n')),Object(r.b)("p",null,"And now we create the actual task."),Object(r.b)("pre",null,Object(r.b)("code",Object(t.a)({parentName:"pre"},{className:"language-csharp"}),"public class RandomSizeTask<TPayload> : ConfigurablePipelineTask<TPayload, RandomSizeConfig> \n    where TPayload : class, IRandomGeneratorPayload, IDungeonPayload\n{\n    public override void Process()\n    {\n        Payload.Size = Payload.Random.Next(Config.MinSize, Config.MaxSize);\n    }\n}\n")),Object(r.b)("p",null,"Note a few things regarding the task:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"it is a generic class"),Object(r.b)("li",{parentName:"ul"},"it inherits from the ",Object(r.b)("inlineCode",{parentName:"li"},"ConfigurablePipelineTask<TPayload, RandomSizeConfig>")," class - with this approach the payload is always an open generic type while the config is always the config class that we created in the previous step"),Object(r.b)("li",{parentName:"ul"},"it has access to ",Object(r.b)("inlineCode",{parentName:"li"},"Payload")," and ",Object(r.b)("inlineCode",{parentName:"li"},"Config")," properties",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Payload")," is of a generic ",Object(r.b)("inlineCode",{parentName:"li"},"TPayload")," type that must implement both ",Object(r.b)("inlineCode",{parentName:"li"},"IDungeonPayload")," and ",Object(r.b)("inlineCode",{parentName:"li"},"IRandomGeneratorPayload")," interfaces"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Config")," is of the ",Object(r.b)("inlineCode",{parentName:"li"},"RandomSizeConfig")," type")))),Object(r.b)("p",null,"To use this task, we first create an instance of the ",Object(r.b)("inlineCode",{parentName:"p"},"RandomSizeConfig")," ScriptableObject and then drag that instance to the ",Object(r.b)("em",{parentName:"p"},"Generator pipeline script"),". We do not do anything with the ",Object(r.b)("inlineCode",{parentName:"p"},"RandomSizeTask")," - the pipeline runner uses some ",Object(r.b)("em",{parentName:"p"},"reflection magic")," to find a corresponding task to each config class."),Object(r.b)("h3",{id:"pros-and-cons-1"},"Pros and cons"),Object(r.b)("p",null,"The biggest advantage of this approach is that we still have a non-generic ScriptableObject that we can use to configure the task in Editor, but we also have a ",Object(r.b)("strong",{parentName:"p"},"generic task")," that uses generic type constraints to enforce that the payload type implements given interfaces."))}p.isMDXComponent=!0},255:function(e,a,n){"use strict";n.d(a,"a",(function(){return b})),n.d(a,"b",(function(){return u}));var t=n(0),i=n.n(t);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function o(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function l(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?o(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function c(e,a){if(null==e)return{};var n,t,i=function(e,a){if(null==e)return{};var n,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(i[n]=e[n]);return i}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=i.a.createContext({}),p=function(e){var a=i.a.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):l(l({},a),e)),n},b=function(e){var a=p(e.components);return i.a.createElement(s.Provider,{value:a},e.children)},d={inlineCode:"code",wrapper:function(e){var a=e.children;return i.a.createElement(i.a.Fragment,{},a)}},m=i.a.forwardRef((function(e,a){var n=e.components,t=e.mdxType,r=e.originalType,o=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),b=p(n),m=t,u=b["".concat(o,".").concat(m)]||b[m]||d[m]||r;return n?i.a.createElement(u,l(l({ref:a},s),{},{components:n})):i.a.createElement(u,l({ref:a},s))}));function u(e,a){var n=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var r=n.length,o=new Array(r);o[0]=m;var l={};for(var c in a)hasOwnProperty.call(a,c)&&(l[c]=a[c]);l.originalType=e,l.mdxType="string"==typeof e?e:t,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);